{% extends 'base.html' %}

{% block extra_head %}
<style>
    .card {
        margin-bottom: 20px;
    }
    .source-card {
        height: 100%;
    }
    .action-buttons {
        display: flex;
        gap: 5px;
    }
    .modal-backdrop {
        opacity: 0.5;
    }
</style>
{% endblock %}

{% block content %}
<div id="app">
    <!-- Settings Section -->
    <div class="card mb-4">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h2 class="h4 mb-0">Settings</h2>
            <div v-if="settingsStatus !== 'idle'" class="d-flex align-items-center">
                <small class="text-muted me-2" v-if="settingsStatus === 'modified'">Modified</small>
                <small class="text-muted me-2" v-if="settingsStatus === 'saving'">Saving...</small>
                <small class="text-success me-2" v-if="settingsStatus === 'saved'">Saved</small>
                <div v-if="settingsStatus === 'saving'" class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Saving...</span>
                </div>
                <i v-if="settingsStatus === 'saved'" class="bi bi-check-circle-fill text-success"></i>
            </div>
        </div>
        <div class="card-body">
            <div class="alert alert-danger" v-if="settingsError">
                [[ settingsError ]]
            </div>

            <div class="mb-3 form-check">
                <input type="checkbox" class="form-check-input" id="syncEnabled" v-model="settings.sync_enabled" @change="onSettingsChange">
                <label class="form-check-label" for="syncEnabled">Sync Enabled</label>
            </div>

            <div class="mb-3">
                <label class="form-label">Sync Schedules</label>

                <div class="mb-3">
                    <div v-for="(schedule, scheduleIndex) in settings.sync_schedules" :key="scheduleIndex" class="card mb-3">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="card-title mb-0">Schedule #[[ scheduleIndex + 1 ]]</h6>
                                <button class="btn btn-sm btn-outline-danger" @click="removeSchedule(scheduleIndex)">
                                    <i class="bi bi-trash"></i> Remove
                                </button>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Time</label>
                                <input type="time" class="form-control" v-model="schedule.time" @change="onSettingsChange">
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Days of Week</label>
                                <div class="d-flex gap-2 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-primary" @click="applyQuickSchedule(scheduleIndex, 'all')">
                                        All Week
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-primary" @click="applyQuickSchedule(scheduleIndex, 'weekdays')">
                                        All Weekdays (Mon-Fri)
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-primary" @click="applyQuickSchedule(scheduleIndex, 'weekend')">
                                        Weekend Only (Sat-Sun)
                                    </button>
                                </div>
                                <div class="d-flex flex-wrap gap-2">
                                    <div v-for="day in daysOfWeek" :key="day" class="form-check">
                                        <input class="form-check-input" type="checkbox" 
                                            :id="'day-' + scheduleIndex + '-' + day"
                                            :value="day"
                                            v-model="schedule.daysOfWeek"
                                            @change="onSettingsChange">
                                        <label class="form-check-label" :for="'day-' + scheduleIndex + '-' + day">
                                            [[ day ]]
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button class="btn btn-outline-primary" @click="addNewSchedule">
                        <i class="bi bi-plus"></i> Add New Schedule
                    </button>
                </div>
            </div>

            <div class="mb-3 form-check">
                <input type="checkbox" class="form-check-input" id="allowChannelAutoDeletion" v-model="settings.allow_channel_auto_deletion" @change="onSettingsChange">
                <label class="form-check-label" for="allowChannelAutoDeletion">Allow Channel Auto-Deletion</label>
            </div>
        </div>
    </div>

    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1 class="h2">Service Providers</h1>
        <button class="btn btn-primary" @click="showAddModal">
            <i class="bi bi-plus"></i> Add New Provider
        </button>
    </div>

    <div class="alert alert-info" v-if="loading">
        <div class="spinner-border spinner-border-sm" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        Loading providers...
    </div>

    <div class="alert alert-danger" v-if="error">
        [[ error ]]
    </div>

    <div class="row" v-if="!loading && !error">
        <div v-if="sources.length === 0" class="col-12">
            <div class="alert alert-warning">
                No providers found. Click "Add New Provider" to create one.
            </div>
        </div>
        <div v-for="source in sources" :key="source.id" class="col-md-4 mb-4">
            <div class="card source-card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h5 class="card-title mb-0">[[ source.name ]]</h5>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" :id="'toggle-' + source.id"
                                v-model="source.is_enabled" @change="toggleSourceEnabled(source)">
                            <label class="form-check-label" :for="'toggle-' + source.id">
                                [[ source.is_enabled ? 'Enabled' : 'Disabled' ]]
                            </label>
                        </div>
                    </div>
                    <p class="card-text">
                        <strong>URL:</strong> <a :href="source.url" target="_blank">[[ source.url ]]</a>
                    </p>
                    <p class="card-text">
                        <strong>Channels:</strong> [[ source.channel_count || 0 ]]<br>
                        <strong>Last Synced:</strong> [[ source.last_synced ? formatDate(source.last_synced) : 'Never' ]]
                    </p>
                    <p class="card-text">
                        <small class="text-muted">
                            Created: [[ formatDate(source.created_at) ]]<br>
                            Updated: [[ formatDate(source.updated_at) ]]
                        </small>
                    </p>
                    <div class="action-buttons">
                        <button class="btn btn-sm btn-primary" @click="showEditModal(source)">
                            <i class="bi bi-pencil"></i> Edit
                        </button>
                        <button class="btn btn-sm btn-danger" @click="confirmDelete(source)">
                            <i class="bi bi-trash"></i> Delete
                        </button>
                        <button class="btn btn-sm btn-success" @click="syncSource(source)" :disabled="source.syncInProgress || !source.is_enabled">
                            <i class="bi" :class="source.syncInProgress ? 'bi-hourglass-split' : 'bi-arrow-repeat'"></i> Sync Now
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Source Modal -->
    <div class="modal fade" id="sourceModal" tabindex="-1" aria-labelledby="sourceModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="sourceModalLabel">[[ editMode ? 'Edit' : 'Add' ]] Provider</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-danger" v-if="formError">
                        [[ formError ]]
                    </div>
                    <form @submit.prevent="saveSource">
                        <div class="mb-3">
                            <label for="sourceName" class="form-label">Name</label>
                            <input type="text" class="form-control" id="sourceName" v-model="currentSource.name" required maxlength="100">
                            <div class="form-text">Required, maximum 100 characters</div>
                        </div>
                        <div class="mb-3">
                            <label for="sourceUrl" class="form-label">URL</label>
                            <input type="url" class="form-control" id="sourceUrl" v-model="currentSource.url" required maxlength="500">
                            <div class="form-text">Required, must be a valid URL, maximum 500 characters</div>
                        </div>
                        <div class="d-flex justify-content-end">
                            <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">Cancel</button>
                            <button type="submit" class="btn btn-primary" :disabled="formSubmitting">
                                <span v-if="formSubmitting" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                Save
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteModalLabel">Confirm Delete</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete the provider "[[ currentSource.name ]]"?</p>
                    <p class="text-danger">This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" @click="deleteSource" :disabled="formSubmitting">
                        <span v-if="formSubmitting" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        Delete
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Sync Progress Modal -->
    <div class="modal fade" id="syncModal" tabindex="-1" aria-labelledby="syncModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="syncModalLabel">Synchronizing "[[ currentSource.name ]]"</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div v-if="syncStatus === 'queued'" class="text-center">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Sync job has been queued and will start shortly...</p>
                    </div>

                    <div v-if="syncStatus === 'in_progress'" class="text-center">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Synchronization in progress...</p>
                        <p>Elapsed time: [[ syncElapsedTime ]]</p>
                    </div>

                    <div v-if="syncStatus === 'completed' && syncSuccess" class="text-center">
                        <i class="bi bi-check-circle-fill text-success" style="font-size: 3rem;"></i>
                        <p class="mt-3">Synchronization completed successfully!</p>
                        <p>Total time: [[ syncElapsedTime ]]</p>
                    </div>

                    <div v-if="syncStatus === 'completed' && !syncSuccess" class="text-center">
                        <i class="bi bi-x-circle-fill text-danger" style="font-size: 3rem;"></i>
                        <p class="mt-3">Synchronization failed.</p>
                        <p>Total time: [[ syncElapsedTime ]]</p>
                    </div>

                    <div v-if="syncStatus === 'error'" class="text-center">
                        <i class="bi bi-exclamation-triangle-fill text-warning" style="font-size: 3rem;"></i>
                        <p class="mt-3">An error occurred while checking sync status.</p>
                        <p class="text-danger">[[ syncErrorMessage ]]</p>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Create Vue app
    const app = new Vue({
        el: '#app',
        delimiters: ['[[', ']]'],
        data: {
            sources: [],
            loading: true,
            error: null,
            currentSource: {
                id: null,
                name: '',
                url: ''
            },
            editMode: false,
            formError: null,
            formSubmitting: false,
            sourceModal: null,
            deleteModal: null,
            syncModal: null,
            // Sync data
            syncStatus: null, // queued, in_progress, completed, error
            syncSuccess: false,
            syncJobId: null,
            syncStartTime: null,
            syncElapsedTime: '00:00:00',
            syncTimer: null,
            syncErrorMessage: null,
            // Settings data
            settings: {
                sync_enabled: false,
                sync_schedules: [],
                allow_channel_auto_deletion: true
            },
            settingsStatus: 'idle', // idle, modified, saving, saved
            settingsError: null,
            settingsTimeout: null,
            daysOfWeek: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        },
        mounted() {
            this.fetchSources();
            this.fetchSettings();
            this.sourceModal = new bootstrap.Modal(document.getElementById('sourceModal'));
            this.deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
            this.syncModal = new bootstrap.Modal(document.getElementById('syncModal'));

            // Add event listener for sync modal close
            document.getElementById('syncModal').addEventListener('hidden.bs.modal', () => {
                // Don't reset sync state when modal is closed
                // This allows the sync to continue in the background
                console.log('Sync modal closed, job continues in background');
            });
        },
        methods: {
            fetchSources() {
                this.loading = true;
                this.error = null;

                axios.get('/api/sources/')
                    .then(response => {
                        // Initialize syncInProgress property for each source
                        const sources = response.data.map(source => ({
                            ...source,
                            syncInProgress: false
                        }));
                        this.sources = sources;
                        this.loading = false;
                    })
                    .catch(error => {
                        console.error('Error fetching sources:', error);
                        this.error = 'Failed to load playlist sources. Please try again later.';
                        this.loading = false;
                    });
            },

            syncSource(source) {
                // Reset sync state
                this.resetSyncState();

                // Set current source
                this.currentSource = {
                    id: source.id,
                    name: source.name,
                    url: source.url
                };

                // Show sync modal
                this.syncModal.show();

                // Start sync
                axios.post(`/api/sources/${source.id}/sync/`)
                    .then(response => {
                        console.log('Sync initiated:', response.data);

                        // Update sync status
                        this.syncStatus = response.data.status;
                        this.syncJobId = response.data.job_id;
                        this.syncStartTime = new Date();

                        // Mark source as syncing
                        const sourceIndex = this.sources.findIndex(s => s.id === source.id);
                        if (sourceIndex !== -1) {
                            this.sources[sourceIndex].syncInProgress = true;
                        }

                        // Start timer to update elapsed time
                        this.startSyncTimer();

                        // Start polling for sync status
                        this.checkSyncStatus();
                    })
                    .catch(error => {
                        console.error('Error initiating sync:', error);
                        this.syncStatus = 'error';
                        this.syncErrorMessage = error.response?.data?.error || 'Failed to initiate sync. Please try again.';
                    });
            },

            checkSyncStatus() {
                if (!this.syncJobId || this.syncStatus === 'completed' || this.syncStatus === 'error') {
                    return;
                }

                axios.get(`/api/sources/${this.currentSource.id}/sync_status/`, {
                    params: { job_id: this.syncJobId }
                })
                    .then(response => {
                        console.log('Sync status:', response.data);

                        // Update sync status
                        this.syncStatus = response.data.status;

                        if (response.data.status === 'completed') {
                            // Sync completed
                            this.syncSuccess = response.data.success;

                            // Stop timer
                            this.stopSyncTimer();

                            // Mark source as not syncing
                            const sourceIndex = this.sources.findIndex(s => s.id === this.currentSource.id);
                            if (sourceIndex !== -1) {
                                this.sources[sourceIndex].syncInProgress = false;
                            }

                            // Refresh sources to get updated data
                            this.fetchSources();
                        } else if (response.data.status === 'in_progress' || response.data.status === 'queued') {
                            // Continue polling
                            setTimeout(() => this.checkSyncStatus(), 2000);
                        }
                    })
                    .catch(error => {
                        console.error('Error checking sync status:', error);
                        this.syncStatus = 'error';
                        this.syncErrorMessage = error.response?.data?.error || 'Failed to check sync status.';

                        // Mark source as not syncing
                        const sourceIndex = this.sources.findIndex(s => s.id === this.currentSource.id);
                        if (sourceIndex !== -1) {
                            this.sources[sourceIndex].syncInProgress = false;
                        }

                        // Stop timer
                        this.stopSyncTimer();
                    });
            },

            startSyncTimer() {
                // Clear any existing timer
                this.stopSyncTimer();

                // Start a new timer that updates every second
                this.syncTimer = setInterval(() => this.updateElapsedTime(), 1000);
            },

            stopSyncTimer() {
                if (this.syncTimer) {
                    clearInterval(this.syncTimer);
                    this.syncTimer = null;
                }
            },

            updateElapsedTime() {
                if (!this.syncStartTime) return;

                const now = new Date();
                const elapsed = Math.floor((now - this.syncStartTime) / 1000); // in seconds

                const hours = Math.floor(elapsed / 3600);
                const minutes = Math.floor((elapsed % 3600) / 60);
                const seconds = elapsed % 60;

                this.syncElapsedTime = 
                    String(hours).padStart(2, '0') + ':' + 
                    String(minutes).padStart(2, '0') + ':' + 
                    String(seconds).padStart(2, '0');
            },

            resetSyncState() {
                this.syncStatus = null;
                this.syncSuccess = false;
                this.syncJobId = null;
                this.syncStartTime = null;
                this.syncElapsedTime = '00:00:00';
                this.syncErrorMessage = null;
                this.stopSyncTimer();
            },
            showAddModal() {
                this.editMode = false;
                this.currentSource = {
                    id: null,
                    name: '',
                    url: ''
                };
                this.formError = null;
                this.sourceModal.show();
            },
            showEditModal(source) {
                this.editMode = true;
                this.currentSource = {
                    id: source.id,
                    name: source.name,
                    url: source.url
                };
                this.formError = null;
                this.sourceModal.show();
            },
            saveSource() {
                this.formSubmitting = true;
                this.formError = null;

                const payload = {
                    name: this.currentSource.name,
                    url: this.currentSource.url
                }

                const request = this.editMode
                    ? axios.patch(`/api/sources/${this.currentSource.id}/`, payload)
                    : axios.post('/api/sources/', payload);

                request
                    .then(() => {
                        this.sourceModal.hide();
                        this.fetchSources();
                        this.formSubmitting = false;
                    })
                    .catch(error => {
                        console.error('Error saving service provider:', error);
                        this.formError = 'Failed to save service provider. Please check your input and try again.';
                        this.formSubmitting = false;
                    });
            },

            toggleSourceEnabled(source) {
                axios.patch(`/api/sources/${source.id}/`, {
                    is_enabled: source.is_enabled
                })
                .then(() => {
                    console.log(`Service provider ${source.id} ${source.is_enabled ? 'enabled' : 'disabled'}`);
                    // Refresh the sources to update the "Updated" timestamp
                    this.fetchSources();
                })
                .catch(error => {
                    console.error('Error toggling service provider enabled state:', error);
                    // Revert the toggle if there was an error
                    source.is_enabled = !source.is_enabled;
                    this.$forceUpdate();
                    alert('Failed to update service provider status. Please try again.');
                });
            },
            confirmDelete(source) {
                this.currentSource = {
                    id: source.id,
                    name: source.name,
                    url: source.url
                };
                this.deleteModal.show();
            },
            deleteSource() {
                this.formSubmitting = true;

                axios.delete(`/api/sources/${this.currentSource.id}/`)
                    .then(() => {
                        this.deleteModal.hide();
                        this.fetchSources();
                        this.formSubmitting = false;
                    })
                    .catch(error => {
                        console.error('Error deleting source:', error);
                        this.formSubmitting = false;
                        // Show error in delete modal
                        document.querySelector('#deleteModal .modal-body').innerHTML += 
                            `<div class="alert alert-danger mt-3">Failed to delete playlist source. Please try again later.</div>`;
                    });
            },
            formatDate(dateString) {
                if (!dateString) return 'N/A';
                const date = new Date(dateString);
                return date.toLocaleString();
            },

            // Settings methods
            fetchSettings() {
                axios.get('/api/settings/')
                    .then(response => {
                        const settingsData = response.data;

                        // Ensure sync_schedules is an array
                        if (!settingsData.sync_schedules) {
                            settingsData.sync_schedules = [];
                        }

                        // Convert schedule times from UTC (as stored on the server) to local browser time zone
                        // This ensures that users see schedules in their own time zone
                        if (settingsData.sync_schedules && settingsData.sync_schedules.length > 0) {
                            settingsData.sync_schedules.forEach(schedule => {
                                // Ensure each schedule has a daysOfWeek array
                                if (!schedule.daysOfWeek) {
                                    schedule.daysOfWeek = [];
                                }

                                if (schedule.time) {
                                    // Parse the UTC time string (HH:MM:SS)
                                    const timeParts = schedule.time.split(':');
                                    const utcHours = parseInt(timeParts[0], 10);
                                    const utcMinutes = parseInt(timeParts[1], 10);
                                    const utcSeconds = timeParts.length > 2 ? parseInt(timeParts[2], 10) : 0;

                                    // Create a Date object with the UTC time
                                    const utcDate = new Date();
                                    utcDate.setUTCHours(utcHours, utcMinutes, utcSeconds, 0);

                                    // Get the local time components
                                    const localHours = utcDate.getHours();
                                    const localMinutes = utcDate.getMinutes();
                                    const localSeconds = utcDate.getSeconds();

                                    // Format as HH:MM:SS
                                    schedule.time = 
                                        String(localHours).padStart(2, '0') + ':' + 
                                        String(localMinutes).padStart(2, '0') + ':' + 
                                        String(localSeconds).padStart(2, '0');

                                    // If the day changed due to timezone conversion, adjust the days of week
                                    // For example, if Monday 5am UTC becomes Sunday 10pm PT, we need to shift the day from Monday to Sunday
                                    if (utcDate.getUTCDate() !== utcDate.getDate()) {
                                        // Determine if we crossed forward or backward
                                        const dayDiff = (utcDate.getDay() - utcDate.getUTCDay() + 7) % 7;

                                        // Shift the days of week accordingly
                                        const shiftedDays = [];
                                        for (const day of schedule.daysOfWeek) {
                                            const dayIndex = this.daysOfWeek.indexOf(day);
                                            if (dayIndex !== -1) {
                                                const newDayIndex = (dayIndex + dayDiff) % 7;
                                                shiftedDays.push(this.daysOfWeek[newDayIndex]);
                                            }
                                        }
                                        schedule.daysOfWeek = shiftedDays;
                                    }
                                }
                            });
                        }

                        this.settings = settingsData;
                        this.settingsError = null;
                    })
                    .catch(error => {
                        console.error('Error fetching settings:', error);
                        this.settingsError = 'Failed to load settings. Please refresh the page.';
                    });
            },

            saveSettings() {
                this.settingsStatus = 'saving';

                // Create a deep copy of the settings to avoid modifying the original
                const settingsToSave = JSON.parse(JSON.stringify(this.settings));

                // Convert schedule times from local browser time zone to UTC
                // This ensures that schedules are stored in a consistent time zone on the server
                if (settingsToSave.sync_schedules && settingsToSave.sync_schedules.length > 0) {
                    settingsToSave.sync_schedules.forEach(schedule => {
                        if (schedule.time) {
                            // Parse the time string (HH:MM or HH:MM:SS)
                            const timeParts = schedule.time.split(':');
                            const hours = parseInt(timeParts[0], 10);
                            const minutes = parseInt(timeParts[1], 10);
                            const seconds = timeParts.length > 2 ? parseInt(timeParts[2], 10) : 0;

                            // Create a Date object for today with the specified time
                            const localDate = new Date();
                            localDate.setHours(hours, minutes, seconds, 0);

                            // Convert to UTC time
                            const utcHours = localDate.getUTCHours();
                            const utcMinutes = localDate.getUTCMinutes();
                            const utcSeconds = localDate.getUTCSeconds();

                            // Format as HH:MM:SS
                            schedule.time = 
                                String(utcHours).padStart(2, '0') + ':' + 
                                String(utcMinutes).padStart(2, '0') + ':' + 
                                String(utcSeconds).padStart(2, '0');

                            // If the day changed due to timezone conversion, adjust the days of week
                            // For example, if Sunday 10pm PT becomes Monday 5am UTC, we need to shift the day from Sunday to Monday
                            if (localDate.getUTCDate() !== localDate.getDate()) {
                                // Determine if we crossed forward or backward
                                const dayDiff = (localDate.getUTCDay() - localDate.getDay() + 7) % 7;

                                // Shift the days of week accordingly
                                const shiftedDays = [];
                                for (const day of schedule.daysOfWeek) {
                                    const dayIndex = this.daysOfWeek.indexOf(day);
                                    if (dayIndex !== -1) {
                                        const newDayIndex = (dayIndex + dayDiff) % 7;
                                        shiftedDays.push(this.daysOfWeek[newDayIndex]);
                                    }
                                }
                                schedule.daysOfWeek = shiftedDays;
                            }
                        }
                    });
                }

                axios.put('/api/settings/', settingsToSave)
                    .then(response => {
                        // Get the response data
                        const responseData = response.data;

                        // Convert schedule times from UTC (as stored on the server) to local browser time zone
                        // This ensures that users see schedules in their own time zone after saving
                        if (responseData.sync_schedules && responseData.sync_schedules.length > 0) {
                            responseData.sync_schedules.forEach(schedule => {
                                if (schedule.time) {
                                    // Parse the UTC time string (HH:MM:SS)
                                    const timeParts = schedule.time.split(':');
                                    const utcHours = parseInt(timeParts[0], 10);
                                    const utcMinutes = parseInt(timeParts[1], 10);
                                    const utcSeconds = timeParts.length > 2 ? parseInt(timeParts[2], 10) : 0;

                                    // Create a Date object with the UTC time
                                    const utcDate = new Date();
                                    utcDate.setUTCHours(utcHours, utcMinutes, utcSeconds, 0);

                                    // Get the local time components
                                    const localHours = utcDate.getHours();
                                    const localMinutes = utcDate.getMinutes();
                                    const localSeconds = utcDate.getSeconds();

                                    // Format as HH:MM:SS
                                    schedule.time = 
                                        String(localHours).padStart(2, '0') + ':' + 
                                        String(localMinutes).padStart(2, '0') + ':' + 
                                        String(localSeconds).padStart(2, '0');

                                    // If the day changed due to timezone conversion, adjust the days of week
                                    if (utcDate.getUTCDate() !== utcDate.getDate()) {
                                        // Determine if we crossed forward or backward
                                        const dayDiff = (utcDate.getDay() - utcDate.getUTCDay() + 7) % 7;

                                        // Shift the days of week accordingly
                                        const shiftedDays = [];
                                        for (const day of schedule.daysOfWeek) {
                                            const dayIndex = this.daysOfWeek.indexOf(day);
                                            if (dayIndex !== -1) {
                                                const newDayIndex = (dayIndex + dayDiff) % 7;
                                                shiftedDays.push(this.daysOfWeek[newDayIndex]);
                                            }
                                        }
                                        schedule.daysOfWeek = shiftedDays;
                                    }
                                }
                            });
                        }

                        // Update the settings with the converted response data
                        this.settings = responseData;
                        this.settingsStatus = 'saved';
                        this.settingsError = null;

                        // Reset status after 3 seconds
                        setTimeout(() => {
                            if (this.settingsStatus === 'saved') {
                                this.settingsStatus = 'idle';
                            }
                        }, 3000);
                    })
                    .catch(error => {
                        console.error('Error saving settings:', error);
                        this.settingsError = 'Failed to save settings. Please try again.';
                        this.settingsStatus = 'idle';
                    });
            },

            onSettingsChange() {
                this.settingsStatus = 'modified';

                // Clear existing timeout
                if (this.settingsTimeout) {
                    clearTimeout(this.settingsTimeout);
                }

                // Set new timeout to save after 3 seconds of inactivity
                this.settingsTimeout = setTimeout(() => {
                    this.saveSettings();
                }, 3000);
            },

            addNewSchedule() {
                // Add a new empty schedule with default time and no days selected
                this.settings.sync_schedules.push({
                    daysOfWeek: [],
                    time: '12:00'
                });
                this.onSettingsChange();
            },

            removeSchedule(index) {
                // Remove a schedule at the specified index
                this.settings.sync_schedules.splice(index, 1);
                this.onSettingsChange();
            },

            addQuickSchedule(type) {
                let daysOfWeek = [];
                const time = '12:00';

                // Set days based on selection type
                if (type === 'all') {
                    daysOfWeek = [...this.daysOfWeek]; // All days
                } else if (type === 'weekdays') {
                    daysOfWeek = this.daysOfWeek.slice(0, 5); // Monday to Friday
                } else if (type === 'weekend') {
                    daysOfWeek = this.daysOfWeek.slice(5, 7); // Saturday and Sunday
                }

                // Add the new schedule
                this.settings.sync_schedules.push({
                    daysOfWeek,
                    time
                });

                this.onSettingsChange();
            },

            applyQuickSchedule(scheduleIndex, type) {
                // Get the schedule at the specified index
                const schedule = this.settings.sync_schedules[scheduleIndex];

                // Set days based on selection type
                if (type === 'all') {
                    schedule.daysOfWeek = [...this.daysOfWeek]; // All days
                } else if (type === 'weekdays') {
                    schedule.daysOfWeek = this.daysOfWeek.slice(0, 5); // Monday to Friday
                } else if (type === 'weekend') {
                    schedule.daysOfWeek = this.daysOfWeek.slice(5, 7); // Saturday and Sunday
                }

                this.onSettingsChange();
            }
        }
    });
</script>
{% endblock %}
