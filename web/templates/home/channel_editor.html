{% extends 'base.html' %}

{% block extra_head %}
<style>
    .channel-logo {
        max-width: 40px;
        max-height: 40px;
        margin-right: 10px;
    }
    .pagination-container {
        display: flex;
        justify-content: center;
        margin-top: 20px;
    }
    .inactive-channel {
        background-color: #fff3cd;
    }
    .reorder-handle {
        cursor: move;
    }
    .order-controls {
        display: flex;
        align-items: center;
    }
    .order-controls i {
        cursor: pointer;
        margin: 0 5px;
    }
    .page-size-selector {
        margin-bottom: 20px;
    }
    .warning-icon {
        color: #ffc107;
        margin-left: 5px;
    }
    .stream-info-popover {
        max-width: 300px;
    }
    .stream-info-thumbnail {
        max-width: 60px;
        max-height: 60px;
        margin-bottom: 10px;
    }
    .sortable-header {
        cursor: pointer;
        user-select: none;
    }
    .sortable-header:hover {
        text-decoration: underline;
    }
    .bi-funnel, .bi-funnel-fill {
        cursor: pointer;
    }
</style>
{% endblock %}

{% block content %}
<div id="app">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <a href="/playlists/" class="btn btn-secondary me-2">
                <i class="bi bi-arrow-left"></i> Back to Playlists
            </a>
            <h1 class="h2 d-inline-block">Channel Editor: [[ playlistName ]]</h1>
        </div>
        <button class="btn btn-primary" @click="showStreamsOffcanvas">
            <i class="bi bi-plus"></i> Add New Channel
        </button>
    </div>

    <div class="alert alert-info" v-if="loading">
        <div class="spinner-border spinner-border-sm" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        Loading channels...
    </div>

    <div class="alert alert-danger" v-if="error">
        [[ error ]]
    </div>

    <div v-if="!loading && !error">
        <div v-if="channels.length === 0" class="alert alert-warning">
            No channels found for this playlist.
        </div>

        <div v-else>
            <!-- Page size selector -->
            <div class="page-size-selector">
                <label for="pageSize" class="form-label">Items per page:</label>
                <select id="pageSize" class="form-select form-select-sm d-inline-block w-auto" v-model="pageSize" @change="onPageSizeChange">
                    <option value="10">10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>

            <div class="table-responsive">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th></th>
                            <th>Ch #</th>
                            <th>Logo</th>
                            <th>Title</th>
                            <th>TVG ID</th>
                            <th>Category</th>
                            <th>Stream</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="channelsTableBody">
                        <tr v-for="channel in channels" :key="channel.id" :class="{'inactive-channel': channel.provider_stream && !channel.provider_stream.is_active}">
                            <td>
                                <div class="order-controls">
                                    <i v-if="currentPage > 1" class="bi bi-caret-left mx-0" @click="moveChannelPageUp(channel)" :title='"Move to Page " + (currentPage - 1)'></i>
                                    <i class="bi bi-grip-vertical reorder-handle mx-0" title="Drag to Reorder"></i>
                                    <i v-if="currentPage < totalPages" class="bi bi-caret-right mx-0" @click="moveChannelPageDown(channel)" :title='"Move to Page " + (currentPage + 1)'></i>
                                </div>
                            </td>
                            <td>[[ channel.num ]]</td>
                            <td>
                                <img v-if="channel.logo_url || (channel.provider_stream && channel.provider_stream.logo_url)" 
                                     :src="channel.logo_url || (channel.provider_stream ? channel.provider_stream.logo_url : '')" 
                                     class="channel-logo" alt="Channel logo"
                                     @error="handleLogoError">
                            </td>
                            <td>[[ channel.title || channel.provider_stream.title ]]</td>
                            <td>[[ channel.tvg_id || channel.provider_stream.tvg_id ]]</td>
                            <td>[[ channel.category ]]</td>
                            <td @click="showStreamDetails(channel, $event)" style="cursor: pointer;">
                                <span>[[ channel.provider_stream.title ]]</span>
                            </td>
                            <td>
                                <button class="btn btn-sm btn-primary me-1" @click="showEditChannelModal(channel)">
                                    <i class="bi bi-pencil"></i> Edit
                                </button>
                                <button class="btn btn-sm btn-danger" @click="confirmDeleteChannel(channel)">
                                    <i class="bi bi-trash"></i> Delete
                                </button>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Pagination -->
            <div class="pagination-container" v-if="totalPages > 1">
                <nav aria-label="Channel list pagination">
                    <ul class="pagination">
                        <li class="page-item" :class="{ disabled: currentPage === 1 }">
                            <a class="page-link" href="#" @click.prevent="loadPage(1)">First</a>
                        </li>
                        <li class="page-item" :class="{ disabled: currentPage === 1 }">
                            <a class="page-link" href="#" @click.prevent="loadPage(currentPage - 1)">Previous</a>
                        </li>

                        <li v-for="page in paginationPages" :key="page" class="page-item" :class="{ active: currentPage === page }">
                            <a class="page-link" href="#" @click.prevent="loadPage(page)">[[ page ]]</a>
                        </li>

                        <li class="page-item" :class="{ disabled: currentPage === totalPages }">
                            <a class="page-link" href="#" @click.prevent="loadPage(currentPage + 1)">Next</a>
                        </li>
                        <li class="page-item" :class="{ disabled: currentPage === totalPages }">
                            <a class="page-link" href="#" @click.prevent="loadPage(totalPages)">Last</a>
                        </li>
                    </ul>
                </nav>
            </div>
        </div>
    </div>

    <!-- Stream Details Popover Template -->
    <div class="d-none">
        <div id="streamDetailsTemplate" class="stream-info-popover">
            <div v-if="selectedChannel && selectedChannel.provider_stream">
                <img v-if="selectedChannel.provider_stream.logo_url" 
                     :src="selectedChannel.provider_stream.logo_url" 
                     class="stream-info-thumbnail" alt="Stream logo"
                     @error="handleLogoError">
                <p><strong>Title:</strong> [[ selectedChannel.provider_stream.title ]]</p>
                <p><strong>TVG ID:</strong> [[ selectedChannel.provider_stream.tvg_id ]]</p>
                <p><strong>Group:</strong> [[ selectedChannel.provider_stream.group ]]</p>
                <p>
                    <strong>Provider:</strong> 
                    [[ selectedChannel.provider_stream.provider.name ]]
                    <i v-if="selectedChannel.provider_stream.provider && !selectedChannel.provider_stream.provider.is_enabled" 
                       class="bi bi-exclamation-triangle-fill warning-icon" 
                       title="Provider is disabled"></i>
                </p>
            </div>
        </div>
    </div>

    <!-- Add/Edit Channel Modal -->
    <div class="modal fade" id="editChannelModal" tabindex="-1" aria-labelledby="addChannelModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addChannelModalLabel">[[ selectedChannel.id ? 'Edit Channel' : 'Add New Channel' ]]</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-danger" v-if="formError">
                        [[ formError ]]
                    </div>
                    <form @submit.prevent="saveChannel">
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label for="channelTitle" class="form-label mb-0">Title</label>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="useStreamTitle" v-model="useStreamTitle">
                                    <label class="form-check-label" for="useStreamTitle">
                                        Use stream
                                    </label>
                                </div>
                            </div>
                            <input v-if="!useStreamTitle"
                                   type="text" class="form-control" id="channelTitle"
                                   v-model="selectedChannel.title"
                                   required="required">
                            <input v-else
                                   type="text" class="form-control"
                                   :value="selectedChannel.provider_stream ? selectedChannel.provider_stream.title : ''"
                                   disabled="disabled">
                            <div class="form-text">Required</div>
                        </div>
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label for="channelLogo" class="form-label mb-0">Logo URL</label>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="useStreamLogo" v-model="useStreamLogo">
                                    <label class="form-check-label" for="useStreamLogo">
                                        Use stream
                                    </label>
                                </div>
                            </div>
                            <input v-if="!useStreamLogo"
                                   type="url" class="form-control" id="channelLogo"
                                   v-model="selectedChannel.logo_url"
                                   required>
                            <input v-else
                                   type="url" class="form-control"
                                   :value="selectedChannel.provider_stream ? selectedChannel.provider_stream.logo_url : ''"
                                   disabled>
                            <div class="form-text">Required, must be a valid URL</div>
                        </div>
                        <div class="mb-3">
                            <label for="channelCategory" class="form-label">Category</label>
                            <div class="input-group">
                                <select class="form-select" id="channelCategory" v-model="selectedChannel.category">
                                    <option value="">Select a category...</option>
                                    <option v-for="category in selectedChannelCategories" :value="category">[[ category ]]</option>
                                </select>
                                <button class="btn btn-outline-secondary" type="button" @click="showNewCategoryModal">Add...</button>
                            </div>
                            <div class="form-text">Optional</div>
                        </div>
                        <div class="d-flex justify-content-end">
                            <button type="button" class="btn btn-secondary me-2" @click="cancelAddEdit">Cancel</button>
                            <button type="submit" class="btn btn-primary" :disabled="formSubmitting || !isFormValid">
                                <span v-if="formSubmitting" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                Save
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>


    <!-- New Category Modal -->
    <div class="modal fade" id="newCategoryModal" tabindex="-1" aria-labelledby="newCategoryModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-sm">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="newCategoryModalLabel">Add New Category</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div v-if="categoryError" class="alert alert-danger">
                        [[ categoryError ]]
                    </div>
                    <div class="mb-3">
                        <label for="newCategoryName" class="form-label">Category Name</label>
                        <input type="text" class="form-control" id="newCategoryName" v-model="newCategoryName">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" @click="addNewCategory" :disabled="!newCategoryName">
                        <span v-if="categorySubmitting" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        Add
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteModalLabel">Confirm Delete</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete the channel "[[ selectedChannel.title || (selectedChannel.provider_stream ? selectedChannel.provider_stream.title : '') ]]"?</p>
                    <p class="text-danger">This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" @click="deleteChannel" :disabled="formSubmitting">
                        <span v-if="formSubmitting" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        Delete
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Streams Selection Offcanvas -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="streamsOffcanvas" aria-labelledby="streamsOffcanvasLabel" style="width: 800px;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="streamsOffcanvasLabel">Select Stream</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div v-if="availableStreamsLoading" class="text-center p-4">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3">Loading streams...</p>
            </div>

            <div v-else-if="availableStreamsError" class="alert alert-danger">
                [[ availableStreamsError ]]
            </div>

            <div v-else-if="availableStreams.length === 0" class="alert alert-info">
                No streams available for this playlist.
                <button v-if="availableStreamsFilters.q || availableStreamsFilters.provider_id || availableStreamsFilters.is_active"
                        type="button" class="btn btn-sm btn-outline-secondary float-end"
                        @click="clearStreamFilterAll">
                    Clear Filters
                </button>
            </div>

            <div v-else>
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Logo</th>
                                <th>
                                    <span class="sortable-header" @click="sortAvailableStreams('title')">Title</span>
                                    <i v-if="availableStreamsSortFields.title.active"
                                       :class="'bi bi-sort-' + (availableStreamsSortFields.title.direction === 'asc' ? 'down' : 'up')"></i>
                                    <i :class='"bi bi-funnel" + (availableStreamsFilters.q ? "-fill" : "") + " ms-1" + (availableStreamsFilters.q ? " text-primary" : "" )'
                                       @click.stop="showStreamFilter($event, 'q')"></i>
                                </th>
                                <th>
                                    <span class="sortable-header" @click="sortAvailableStreams('group')">Group</span>
                                    <i v-if="availableStreamsSortFields.group.active"
                                       :class="'bi bi-sort-' + (availableStreamsSortFields.group.direction === 'asc' ? 'down' : 'up')"></i>
                                </th>
                                <th>
                                    Provider
                                    <i :class='"bi bi-funnel" + (availableStreamsFilters.provider_id ? "-fill" : "") + " ms-1" + (availableStreamsFilters.provider_id ? " text-primary" : "")'
                                       @click.stop="showStreamFilter($event, 'provider')"></i>
                                </th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-for="stream in availableStreams" :key="stream.id" :class="{'inactive-channel': !stream.is_active}">
                                <td>
                                    <img v-if="stream.logo_url" :src="stream.logo_url" class="channel-logo" alt="Channel logo" @error="handleLogoError">
                                </td>
                                <td>
                                    <span :title="stream.tvg_id">[[ stream.title ]]</span>
                                </td>
                                <td>[[ stream.group ]]</td>
                                <td>
                                    [[ stream.provider.name ]]
                                    <i v-if="stream.provider && !stream.provider.is_enabled" 
                                       class="bi bi-exclamation-triangle-fill warning-icon" 
                                       title="Provider is disabled"></i>
                                </td>
                                <td>
                                    <button class="btn btn-sm btn-primary" @click="showAddChannelModal(stream)">
                                        Add
                                    </button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Pagination -->
                <div class="pagination-container" v-if="availableStreamsTotalPages > 1">
                    <nav aria-label="Available streams pagination">
                        <ul class="pagination">
                            <li class="page-item" :class="{ disabled: availableStreamsCurrentPage === 1 }">
                                <a class="page-link" href="#" @click.prevent="loadAvailableStreamsPage(1)">First</a>
                            </li>
                            <li class="page-item" :class="{ disabled: availableStreamsCurrentPage === 1 }">
                                <a class="page-link" href="#" @click.prevent="loadAvailableStreamsPage(availableStreamsCurrentPage - 1)">Previous</a>
                            </li>

                            <li v-for="page in availableStreamsPaginationPages" :key="page" class="page-item" :class="{ active: availableStreamsCurrentPage === page }">
                                <a class="page-link" href="#" @click.prevent="loadAvailableStreamsPage(page)">[[ page ]]</a>
                            </li>

                            <li class="page-item" :class="{ disabled: availableStreamsCurrentPage === availableStreamsTotalPages }">
                                <a class="page-link" href="#" @click.prevent="loadAvailableStreamsPage(availableStreamsCurrentPage + 1)">Next</a>
                            </li>
                            <li class="page-item" :class="{ disabled: availableStreamsCurrentPage === availableStreamsTotalPages }">
                                <a class="page-link" href="#" @click.prevent="loadAvailableStreamsPage(availableStreamsTotalPages)">Last</a>
                            </li>
                        </ul>
                    </nav>
                </div>

                <div class="mt-3">
                    <small class="text-muted">Note: Grayed-out rows indicate inactive streams.</small>
                </div>
            </div>
        </div>
    </div>

    <!-- Title filter modal -->
    <div class="modal fade" id="filterTitleModal" tabindex="-1" aria-labelledby="filterTitleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-sm">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="filterTitleModalLabel">Filter by Title</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <input type="text" class="form-control" id="titleFilter" placeholder="Search text..." v-model="availableStreamsFilters.q"/>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-sm btn-secondary" @click="clearStreamFilter('q')">Clear</button>
                    <button type="button" class="btn btn-sm btn-primary" @click="applyStreamFilter('q', availableStreamsFilters.q)" :disabled="!availableStreamsFilters.q">Apply</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Provider filter modal -->
    <div class="modal fade" id="filterProviderModal" tabindex="-1" aria-labelledby="filterProviderModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-sm">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="filterProviderModalLabel">Filter by Provider</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <select class="form-select" id="providerFilter" v-model="availableStreamsFilters.provider_id">
                            <option v-for="provider in providers" :value="provider.id">[[ provider.name ]]</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-sm btn-secondary" @click="clearStreamFilter('provider_id')">Clear</button>
                    <button type="button" class="btn btn-sm btn-primary" @click="applyStreamFilter('provider_id', availableStreamsFilters.provider_id)" :disabled="!availableStreamsFilters.provider_id">Apply</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
<script>
    // Create Vue app
    const app = new Vue({
        el: '#app',
        delimiters: ['[[', ']]'],
        data: {
            playlistId: "{{ playlist_id }}",
            playlistName: '',
            channels: [],
            loading: true,
            error: null,
            currentPage: 1,
            totalPages: 1,
            totalChannels: 0,
            pageSize: 10,
            sortable: null,
            popover: null,
            // Add/Edit Channel Modal
            editChannelModal: null,
            newCategoryModal: null,
            selectedChannel: {
                id: null,
                title: '',
                tvg_id: '',
                logo_url: '',
                category: '',
                provider_stream: null
            },
            useStreamTitle: true,
            useStreamLogo: true,
            formError: null,
            formSubmitting: false,
            providers: [],
            categories: [],
            selectedChannelCategories: [],
            newCategoryName: '',
            categoryError: null,
            categorySubmitting: false,
            // Streams Offcanvas
            streamsOffcanvas: null,
            availableStreams: [],
            availableStreamsLoading: false,
            availableStreamsError: null,
            availableStreamsCurrentPage: 1,
            availableStreamsTotalPages: 1,
            availableStreamsPageSize: 10,
            // Sorting and filtering
            availableStreamsSortBy: 'group,title',
            availableStreamsSortFields: {
                title: { active: false, direction: 'asc' },
                group: { active: true, direction: 'asc' }
            },
            availableStreamsFilters: {
                q: '',
                provider_id: '',
                is_active: ''
            },
            // Delete Channel
            deleteModal: null,
            // Filter Modals
            filterTitleModal: null,
            filterProviderModal: null,
        },
        mounted() {
            this.fetchPlaylist();
            this.loadPage(1);
            this.fetchProviders();
            this.fetchCategories()

            // Initialize modals and offcanvas
            this.editChannelModal = new bootstrap.Modal(document.getElementById('editChannelModal'));
            this.streamsOffcanvas = new bootstrap.Offcanvas(document.getElementById('streamsOffcanvas'));
            this.newCategoryModal = new bootstrap.Modal(document.getElementById('newCategoryModal'));
            this.deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
            this.filterTitleModal = new bootstrap.Modal(document.getElementById('filterTitleModal'));
            this.filterProviderModal = new bootstrap.Modal(document.getElementById('filterProviderModal'));

            // Initialize Sortable.js after the DOM is updated
            this.$nextTick(() => {
                this.initSortable();
            });
        },
        computed: {
            paginationPages() {
                // Generate an array of page numbers to display in pagination
                // Show at most 5 pages, centered around the current page
                const totalPages = this.totalPages;
                const currentPage = this.currentPage;

                if (totalPages <= 5) {
                    // If there are 5 or fewer pages, show all of them
                    return Array.from({ length: totalPages }, (_, i) => i + 1);
                } else {
                    // Otherwise, show 5 pages centered around the current page
                    let startPage = Math.max(currentPage - 2, 1);
                    let endPage = startPage + 4;

                    if (endPage > totalPages) {
                        endPage = totalPages;
                        startPage = Math.max(endPage - 4, 1);
                    }

                    return Array.from({ length: endPage - startPage + 1 }, (_, i) => startPage + i);
                }
            },
            isFormValid() {
                // Check if the form is valid
                if (!this.selectedChannel.provider_stream) {
                    return false;
                }

                // Check if title is valid
                if (!this.useStreamTitle && (!this.selectedChannel.title || !this.selectedChannel.title.trim())) {
                    return false;
                }

                // Check if logo URL is valid
                return !(!this.useStreamLogo && (!this.selectedChannel.logo_url || !this.selectedChannel.logo_url.trim()));
            },
            availableStreamsPaginationPages() {
                // Generate an array of page numbers to display in pagination
                // Show at most 5 pages, centered around the current page
                const totalPages = this.availableStreamsTotalPages;
                const currentPage = this.availableStreamsCurrentPage;

                if (totalPages <= 5) {
                    // If there are 5 or fewer pages, show all of them
                    return Array.from({ length: totalPages }, (_, i) => i + 1);
                } else {
                    // Otherwise, show 5 pages centered around the current page
                    let startPage = Math.max(currentPage - 2, 1);
                    let endPage = startPage + 4;

                    if (endPage > totalPages) {
                        endPage = totalPages;
                        startPage = Math.max(endPage - 4, 1);
                    }

                    return Array.from({ length: endPage - startPage + 1 }, (_, i) => startPage + i);
                }
            }
        },
        methods: {
            fetchPlaylist() {
                axios.get(`/api/playlists/${this.playlistId}/`)
                    .then(response => {
                        this.playlistName = response.data.name;
                    })
                    .catch(error => {
                        console.error('Error fetching playlist:', error);
                        this.error = 'Failed to load playlist information.';
                    });
            },
            loadPage(page) {
                this.loading = true;
                this.error = null;

                // Fetch channels for the specified page
                axios.get(`/api/playlists/${this.playlistId}/channels/`, {
                    params: {
                        page: page,
                        size: this.pageSize
                    }
                })
                .then(response => {
                    // Update channels data
                    this.channels = response.data.items;
                    this.currentPage = response.data.page;
                    this.totalChannels = response.data.total;
                    this.totalPages = Math.ceil(this.totalChannels / this.pageSize);
                    this.loading = false;

                    // Re-initialize sortable after data is loaded
                    this.$nextTick(() => {
                        this.initSortable();
                    });
                })
                .catch(error => {
                    console.error('Error fetching channels:', error);
                    this.error = 'Failed to load channels. Please try again.';
                    this.loading = false;
                });
            },
            onPageSizeChange() {
                // Reset to first page when page size changes
                this.loadPage(1);
            },
            initSortable() {
                const el = document.getElementById('channelsTableBody');
                if (el) {
                    this.sortable = new Sortable(el, {
                        handle: '.reorder-handle',
                        animation: 150,
                        onEnd: this.handleDragEnd,
                        draggable: 'tr',
                    });
                }
            },
            handleDragEnd(evt) {
                const channel = this.channels[evt.oldIndex];
                const newOrder = evt.newIndex + 1 + (this.currentPage - 1) * this.pageSize;

                // Update the order in the backend
                this.updateChannelOrder(channel.id, newOrder);
            },
            updateChannelOrder(channelId, newOrder) {
                axios.patch(`/api/channels/${channelId}/`, {
                    order: newOrder
                })
                .then(() => {
                    console.log(`Channel ${channelId} order updated to ${newOrder}`);

                    // Reload the page to reflect the changes
                    const pageToLoad = Math.ceil(newOrder / this.pageSize)
                    this.loadPage(pageToLoad);
                })
                .catch(error => {
                    console.error('Error updating channel order:', error);
                    this.error = 'Failed to update channel order. Please try again.';
                });
            },
            moveChannelPageUp(channel) {
                if (this.currentPage === 1) {
                    return;
                }

                // Move channel up (decrease order)
                const currentOrder = (this.currentPage - 1) * this.pageSize + this.channels.indexOf(channel) + 1;
                const newOrder = currentOrder - this.pageSize;
                this.updateChannelOrder(channel.id, newOrder);
            },
            moveChannelPageDown(channel) {
                if (this.currentPage === this.totalPages) {
                    return;
                }

                // Move channel down (increase order)
                const currentOrder = (this.currentPage - 1) * this.pageSize + this.channels.indexOf(channel) + 1;
                const newOrder = Math.min(currentOrder + this.pageSize, this.totalChannels);
                this.updateChannelOrder(channel.id, newOrder);
            },
            showStreamDetails(channel, event) {
                // Hide any existing popovers
                if (this.popover) {
                    this.closePopover(event);
                }

                this.selectedChannel = channel;

                // Use Bootstrap's popover
                this.$nextTick(() => {
                    const popoverTrigger = event.currentTarget;
                    const popoverContent = document.getElementById('streamDetailsTemplate').innerHTML;

                    this.popover = new bootstrap.Popover(popoverTrigger, {
                        html: true,
                        content: popoverContent,
                        placement: 'auto',
                        trigger: 'manual',
                        container: 'body'
                    });

                    this.popover.show();

                    // Add click event to close popover when clicking outside
                    // Use setTimeout to delay adding the event listener until after the current event has finished propagating
                    setTimeout(() => {
                        document.addEventListener('click', this.closePopover);
                    }, 0);
                });
            },
            closePopover(event) {
                // Close popover when clicking outside
                if (this.popover && !event.target.closest('.popover') && 
                    !event.target.closest('[data-bs-toggle="popover"]')) {
                    this.popover.dispose();
                    this.popover = null;
                    document.removeEventListener('click', this.closePopover);
                }
            },
            handleLogoError(event) {
                // Replace broken image with a placeholder or hide it
                event.target.style.display = 'none';
            },

            // Add Channel Modal Methods
            fetchProviders() {
                axios.get('/api/providers/')
                    .then(response => {
                        this.providers = response.data.items;
                    })
                    .catch(error => {
                        console.error('Error fetching providers:', error);
                        this.formError = 'Failed to load providers. Please try again.';
                    });
            },

            fetchCategories() {
                axios.get(`/api/playlists/${this.playlistId}/categories/`)
                    .then(response => {
                        this.categories = response.data.items;
                    })
                    .catch(error => {
                        console.error('Error fetching categories:', error);
                    });
            },

            showNewCategoryModal() {
                // Reset form
                this.newCategoryName = '';
                this.categoryError = null;
                this.categorySubmitting = false;

                // Show modal
                this.newCategoryModal.show();
            },

            addNewCategory() {
                if (!this.newCategoryName) {
                    this.categoryError = 'Please enter a category name.';
                    return;
                }

                this.categorySubmitting = true;
                this.categoryError = null;

                // Check if category already exists
                if (this.selectedChannelCategories.includes(this.newCategoryName)) {
                    this.categoryError = 'This category already exists.';
                    this.categorySubmitting = false;
                    return;
                }

                // Add the new category to the list
                this.selectedChannelCategories.push(this.newCategoryName);
                this.selectedChannelCategories.sort()

                // Set the new category as the selected one
                this.selectedChannel.category = this.newCategoryName;

                // Close the modal
                this.newCategoryModal.hide();
                this.categorySubmitting = false;
            },

            showStreamsOffcanvas() {
                // Reset streams data but keep filtering, sorting, and pagination settings
                this.availableStreams = [];
                this.availableStreamsError = null;

                // Show offcanvas
                this.streamsOffcanvas.show();

                // Load current page of available streams with current filters and sorting
                this.loadAvailableStreamsPage(this.availableStreamsCurrentPage);
            },

            loadAvailableStreamsPage(page) {
                this.availableStreamsLoading = true;
                this.availableStreamsError = null;

                // Build params object with all filters and sorting
                const params = {
                    page: page,
                    size: this.availableStreamsPageSize,
                    sort_by: this.availableStreamsSortBy
                };

                // Add filters if they exist
                // For title, use the 'q' parameter which searches across title, tvg_id, and group
                if (this.availableStreamsFilters.q) {
                    params.q = this.availableStreamsFilters.q;
                }
                if (this.availableStreamsFilters.provider_id) {
                    params.provider_id = this.availableStreamsFilters.provider_id;
                }
                if (this.availableStreamsFilters.is_active !== '') {
                    params.is_active = this.availableStreamsFilters.is_active;
                }

                // Fetch available streams for the specified page
                axios.get(`/api/playlists/${this.playlistId}/available_streams/`, { params })
                .then(response => {
                    // Update available streams data
                    this.availableStreams = response.data.items;
                    this.availableStreamsCurrentPage = response.data.page;
                    this.availableStreamsTotalPages = Math.ceil(response.data.total / this.availableStreamsPageSize);
                    this.availableStreamsLoading = false;
                })
                .catch(error => {
                    console.error('Error fetching available streams:', error);
                    this.availableStreamsError = 'Failed to load available streams. Please try again.';
                    this.availableStreamsLoading = false;
                });
            },

            sortAvailableStreams(field) {
                // Update sort direction
                if (this.availableStreamsSortFields[field].active) {
                    // Toggle direction if already active
                    this.availableStreamsSortFields[field].direction = 
                        this.availableStreamsSortFields[field].direction === 'asc' ? 'desc' : 'asc';
                } else {
                    // Set as active and default to ascending
                    Object.keys(this.availableStreamsSortFields).forEach(key => {
                        this.availableStreamsSortFields[key].active = (key === field);
                    });
                    this.availableStreamsSortFields[field].direction = 'asc';
                }

                // Build sort_by parameter
                if (this.availableStreamsSortFields[field].direction === 'desc') {
                    this.availableStreamsSortBy = `-${field}`;
                } else {
                    this.availableStreamsSortBy = field;
                }

                // Reload with new sorting
                this.loadAvailableStreamsPage(1);
            },

            showStreamFilter(event, filterType) {
                // Show the appropriate modal based on filter type
                if (filterType === 'q') {
                    this.filterTitleModal.show();
                } else if (filterType === 'provider') {
                    this.filterProviderModal.show();
                }
            },

            applyStreamFilter(filterType, value) {
                // Apply the filter
                this.availableStreamsFilters[filterType] = value;

                // Close the appropriate modal
                if (filterType === 'q') {
                    this.filterTitleModal.hide();
                } else if (filterType === 'provider_id') {
                    this.filterProviderModal.hide();
                }

                // Reload with new filter
                this.loadAvailableStreamsPage(1);
            },

            clearStreamFilter(filterType) {
                // Clear the filter
                this.availableStreamsFilters[filterType] = '';

                // Close the appropriate modal
                if (filterType === 'q') {
                    this.filterTitleModal.hide();
                } else if (filterType === 'provider_id') {
                    this.filterProviderModal.hide();
                }

                // Reload without this filter
                this.loadAvailableStreamsPage(1);
            },

            clearStreamFilterAll() {
                // Clear the filters
                this.availableStreamsFilters['q'] = '';
                this.availableStreamsFilters['is_active'] = '';
                this.availableStreamsFilters['provider_id'] = '';

                // Reload without this filter
                this.loadAvailableStreamsPage(1);
            },

            showAddChannelModal(stream) {
                // Reset form
                this.selectedChannel = {
                    id: null,
                    title: '',
                    tvg_id: '',
                    logo_url: '',
                    category: '',
                    provider_stream: stream
                };
                this.formError = null;
                this.formSubmitting = false;
                this.useStreamTitle = true;
                this.useStreamLogo = true;

                this.selectedChannelCategories = [...this.categories];

                // Show modal
                this.editChannelModal.show();
            },

            cancelAddEdit() {
                // Close the edit modal
                this.editChannelModal.hide();

                if (!this.selectedChannel.id) {
                    // If adding, go back to the offcanvas
                    this.streamsOffcanvas.show();
                }
            },

            showEditChannelModal(channel) {
                // Set to edit mode and populate form with channel data
                this.selectedChannel = { ...channel };
                this.formError = null;
                this.formSubmitting = false;

                // Determine if using stream values or custom values
                this.useStreamTitle = !channel.title || channel.title === channel.provider_stream.title;
                this.useStreamLogo = !channel.logo_url || channel.logo_url === channel.provider_stream.logo_url;

                this.selectedChannelCategories = [...this.categories];

                // Show modal
                this.editChannelModal.show();
            },


            saveChannel() {
                // Validate form
                if (!this.isFormValid) {
                    this.formError = 'Please fill in all required fields.';
                    return;
                }

                this.formSubmitting = true;
                this.formError = null;

                // Prepare payload
                const payload = {};

                // Handle title based on useStreamTitle checkbox
                if (!this.useStreamTitle) {
                    payload.title = this.selectedChannel.title;
                } else {
                    payload.title = null;
                }

                // Add category if it has a value
                if (this.selectedChannel.category) {
                    payload.category = this.selectedChannel.category;
                }

                // Handle logo URL based on useStreamLogo checkbox
                if (!this.useStreamLogo) {
                    payload.logo_url = this.selectedChannel.logo_url;
                } else {
                    payload.logo_url = null;
                }

                if (this.selectedChannel.id) {
                    // Send request to update channel
                    axios.patch(`/api/channels/${this.selectedChannel.id}/`, payload)
                        .then(_ => {
                            // Close modal
                            this.editChannelModal.hide();

                            // Refresh channels
                            this.loadPage(this.currentPage);

                            // Refresh categories, if needed
                            if (this.selectedChannel.category && !this.categories.includes(this.selectedChannel.category)) {
                                this.fetchCategories();
                            }

                            // Reset form
                            this.formSubmitting = false;
                            this.selectedChannelCategories = [];
                        })
                        .catch(error => {
                            console.error('Error updating channel:', error);
                            this.formError = 'Failed to update channel. Please check your input and try again.';
                            this.formSubmitting = false;
                        });
                } else {
                    payload.provider_stream_id = this.selectedChannel.provider_stream.id;

                    // Send request to add channel
                    axios.post(`/api/playlists/${this.playlistId}/channels/`, payload)
                        .then(_ => {
                            // Close modal and offcanvas
                            this.editChannelModal.hide();
                            this.streamsOffcanvas.hide();

                            // Refresh channels
                            this.loadPage(this.currentPage);

                            // Refresh categories, if needed
                            if (this.selectedChannel.category && !this.categories.includes(this.selectedChannel.category)) {
                                this.fetchCategories();
                            }

                            // Reset form
                            this.formSubmitting = false;
                            this.selectedChannelCategories = [];
                        })
                        .catch(error => {
                            console.error('Error adding channel:', error);
                            this.formError = 'Failed to add channel. Please check your input and try again.';
                            this.formSubmitting = false;
                        });
                }
            },

            formatDate(dateString) {
                if (!dateString) return 'N/A';
                const date = new Date(dateString);
                return date.toLocaleString();
            },

            deleteChannel() {
                axios.delete(`/api/channels/${this.selectedChannel.id}/`)
                    .then(() => {
                        // Refresh the channel list after successful deletion
                        this.loadPage(this.currentPage);
                        if (this.selectedChannel.category) {
                            this.fetchCategories();
                        }
                    })
                    .catch(error => {
                        console.error('Error deleting channel:', error);
                        this.error = 'Failed to delete channel. Please try again.';
                    });
            },

            confirmDeleteChannel(channel) {
                this.selectedChannel = channel;
                this.deleteModal.show();
            },
        }
    });
</script>
{% endblock %}
