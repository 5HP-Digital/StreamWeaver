{% extends 'base.html' %}

{% block extra_head %}
<style>
    .card {
        margin-bottom: 20px;
    }
    .provider-card {
        height: 100%;
    }
    .action-buttons {
        display: flex;
        gap: 5px;
    }
    .modal-backdrop {
        opacity: 0.5;
    }
    .channel-count-link {
        color: #0d6efd;
        cursor: pointer;
        text-decoration: underline;
    }
    .channel-count-link:hover {
        color: #0a58ca;
    }
    .inactive-channel {
        opacity: 0.5;
    }
    .channel-logo {
        max-width: 40px;
        max-height: 40px;
        margin-right: 10px;
    }
    .pagination-container {
        display: flex;
        justify-content: center;
        margin-top: 20px;
    }
    .active-jobs-section {
        margin-bottom: 20px;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 20px;
    }
    .job-state-badge {
        display: inline-block;
        padding: 0.25em 0.4em;
        font-size: 75%;
        font-weight: 700;
        line-height: 1;
        text-align: center;
        white-space: nowrap;
        vertical-align: baseline;
        border-radius: 0.25rem;
    }
    .job-state-queued {
        background-color: #17a2b8;
        color: white;
    }
    .job-state-inprogress {
        background-color: #ffc107;
        color: black;
    }
    .job-state-completed {
        background-color: #28a745;
        color: white;
    }
    .job-state-failed {
        background-color: #dc3545;
        color: white;
    }
</style>
{% endblock %}

{% block content %}
<div id="app">
    <!-- Settings Section -->
    <div class="card mb-4">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h2 class="h4 mb-0">Settings</h2>
            <div v-if="settingsStatus !== 'idle'" class="d-flex align-items-center">
                <small class="text-muted me-2" v-if="settingsStatus === 'modified'">Modified</small>
                <small class="text-muted me-2" v-if="settingsStatus === 'saving'">Saving...</small>
                <small class="text-success me-2" v-if="settingsStatus === 'saved'">Saved</small>
                <div v-if="settingsStatus === 'saving'" class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Saving...</span>
                </div>
                <i v-if="settingsStatus === 'saved'" class="bi bi-check-circle-fill text-success"></i>
            </div>
        </div>
        <div class="card-body">
            <div class="alert alert-danger" v-if="settingsError">
                [[ settingsError ]]
            </div>

            <div class="mb-3 form-check">
                <input type="checkbox" class="form-check-input" id="syncEnabled" v-model="settings.sync_enabled" @change="onSettingsChange">
                <label class="form-check-label" for="syncEnabled">Sync Enabled</label>
            </div>

            <div class="mb-3">
                <label class="form-label">Sync Schedules</label>

                <div class="mb-3">
                    <div v-for="(schedule, scheduleIndex) in settings.sync_schedules" :key="scheduleIndex" class="card mb-3">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="card-title mb-0">Schedule #[[ scheduleIndex + 1 ]]</h6>
                                <button class="btn btn-sm btn-outline-danger" @click="removeSchedule(scheduleIndex)">
                                    <i class="bi bi-trash"></i> Remove
                                </button>
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Time</label>
                                <input type="time" class="form-control" v-model="schedule.time" @change="onSettingsChange">
                            </div>

                            <div class="mb-3">
                                <label class="form-label">Days of Week</label>
                                <div class="d-flex gap-2 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-primary" @click="applyQuickSchedule(scheduleIndex, 'all')">
                                        All Week
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-primary" @click="applyQuickSchedule(scheduleIndex, 'weekdays')">
                                        All Weekdays (Mon-Fri)
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-primary" @click="applyQuickSchedule(scheduleIndex, 'weekend')">
                                        Weekend Only (Sat-Sun)
                                    </button>
                                </div>
                                <div class="d-flex flex-wrap gap-2">
                                    <div v-for="day in daysOfWeek" :key="day" class="form-check">
                                        <input class="form-check-input" type="checkbox" 
                                            :id="'day-' + scheduleIndex + '-' + day"
                                            :value="day"
                                            v-model="schedule.daysOfWeek"
                                            @change="onSettingsChange">
                                        <label class="form-check-label" :for="'day-' + scheduleIndex + '-' + day">
                                            [[ day ]]
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button class="btn btn-outline-primary" @click="addNewSchedule">
                        <i class="bi bi-plus"></i> Add New Schedule
                    </button>
                </div>
            </div>

            <div class="mb-3 form-check">
                <input type="checkbox" class="form-check-input" id="allowChannelAutoDeletion" v-model="settings.allow_channel_auto_deletion" @change="onSettingsChange">
                <label class="form-check-label" for="allowChannelAutoDeletion">Allow Channel Auto-Deletion</label>
            </div>

            <div class="mb-3">
                <label class="form-label" for="syncJobMaxAttempts">Failed Sync Attempt Limit</label>
                <div class="d-flex align-items-center">
                    <select class="form-select" id="syncJobMaxAttempts" v-model="settings.sync_job_max_attempts" @change="onSettingsChange">
                        <option v-for="n in 100" :key="n" :value="n">[[ n ]]</option>
                        <option :value="null">Unlimited</option>
                    </select>
                </div>
                <div class="form-text">Maximum number of retry attempts for failed sync jobs. Select "Unlimited" for no limit.</div>
            </div>
        </div>
    </div>

    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1 class="h2">Service Providers</h1>
        <button class="btn btn-primary" @click="showAddModal">
            <i class="bi bi-plus"></i> Add New Provider
        </button>
    </div>

    <div class="alert alert-info" v-if="loading">
        <div class="spinner-border spinner-border-sm" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        Loading providers...
    </div>

    <div class="alert alert-danger" v-if="error">
        [[ error ]]
    </div>

    <div class="row" v-if="!loading && !error">
        <div v-if="providers.length === 0" class="col-12">
            <div class="alert alert-warning">
                No providers found. Click "Add New Provider" to create one.
            </div>
        </div>
        <div v-for="provider in providers" :key="provider.id" class="col-md-4 mb-4">
            <div class="card provider-card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h5 class="card-title mb-0">[[ provider.name ]]</h5>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" :id="'toggle-' + provider.id"
                                v-model="provider.is_enabled" @change="toggleProviderEnabled(provider)">
                            <label class="form-check-label" :for="'toggle-' + provider.id">
                                [[ provider.is_enabled ? 'Enabled' : 'Disabled' ]]
                            </label>
                        </div>
                    </div>
                    <p class="card-text">
                        <strong>URL:</strong> <a :href="provider.url" target="_blank" class="url-ellipsis">[[ provider.url ]]</a>
                    </p>
                    <p class="card-text">
                        <strong>Channels:</strong> 
                        <span v-if="provider.channel_count > 0"
                              class="channel-count-link" 
                              @click="showChannelsModal(provider)">
                            [[ provider.channel_count ]]
                        </span>
                        <span v-else>[[ 0 ]]</span>
                        <br>
                        <strong>Last Synced:</strong> [[ provider.last_synced ? formatDate(provider.last_synced) : 'Never' ]]
                    </p>
                    <p class="card-text">
                        <small class="text-muted">
                            Created: [[ formatDate(provider.created_at) ]]<br>
                            Updated: [[ formatDate(provider.updated_at) ]]
                        </small>
                    </p>
                    <div class="action-buttons">
                        <button class="btn btn-sm btn-primary" @click="showEditModal(provider)">
                            <i class="bi bi-pencil"></i> Edit
                        </button>
                        <button class="btn btn-sm btn-danger" @click="confirmDelete(provider)">
                            <i class="bi bi-trash"></i> Delete
                        </button>
                        <button class="btn btn-sm btn-success" @click="syncProvider(provider)" :disabled="!provider.is_enabled || provider.active_job_id">
                            <i class="bi" :class="provider.active_job_id ? 'bi-hourglass-split' : 'bi-arrow-repeat'"></i>
                            <span v-if="provider.active_job_id">Syncing...</span>
                            <span v-else>Sync Now</span>
                        </button>
                        <button class="btn btn-sm btn-info" @click="showJobHistoryModal(provider)">
                            <i class="bi bi-clock-history"></i> History
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Provider Modal -->
    <div class="modal fade" id="providerModal" tabindex="-1" aria-labelledby="providerModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="providerModalLabel">[[ editMode ? 'Edit' : 'Add' ]] Provider</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-danger" v-if="formError">
                        [[ formError ]]
                    </div>
                    <form @submit.prevent="saveProvider">
                        <div class="mb-3">
                            <label for="providerName" class="form-label">Name</label>
                            <input type="text" class="form-control" id="providerName" v-model="currentProvider.name" required maxlength="100">
                            <div class="form-text">Required, maximum 100 characters</div>
                        </div>
                        <div class="mb-3">
                            <label for="providerUrl" class="form-label">URL</label>
                            <input type="url" class="form-control" id="providerUrl" v-model="currentProvider.url" required maxlength="500">
                            <div class="form-text">Required, must be a valid URL, maximum 500 characters</div>
                        </div>
                        <div class="d-flex justify-content-end">
                            <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">Cancel</button>
                            <button type="submit" class="btn btn-primary" :disabled="formSubmitting">
                                <span v-if="formSubmitting" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                Save
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteModalLabel">Confirm Delete</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete the provider "[[ currentProvider.name ]]"?</p>
                    <p class="text-danger">This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" @click="deleteProvider" :disabled="formSubmitting">
                        <span v-if="formSubmitting" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        Delete
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Channels List Modal -->
    <div class="modal fade channel-list-modal" id="channelsModal" tabindex="-1" aria-labelledby="channelsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="channelsModalLabel">Channels for "[[ currentProvider.name ]]"</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div v-if="channelsLoading" class="text-center p-4">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Loading channels...</p>
                    </div>

                    <div v-else-if="channelsError" class="alert alert-danger">
                        [[ channelsError ]]
                    </div>

                    <div v-else-if="channels.length === 0" class="alert alert-info">
                        No channels found for this provider.
                    </div>

                    <div v-else>
                        <div class="table-responsive">
                            <table class="table table-striped">
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th>Name</th>
                                        <th>TVG-ID</th>
                                        <th>Group</th>
                                        <th>Updated</th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="channel in channels" :key="channel.id" :class="{'inactive-channel': !channel.is_active}">
                                        <td>
                                            <img v-if="channel.logo_url" :src="channel.logo_url" class="channel-logo" @error="handleLogoError">
                                        </td>
                                        <td>
                                            <div class="d-flex align-items-center">
                                                [[ channel.title ]]
                                            </div>
                                        </td>
                                        <td>[[ channel.tvg_id ]]</td>
                                        <td>[[ channel.group ]]</td>
                                        <td>[[ formatDate(channel.updated_at) ]]</td>
                                        <td>
                                            <button class="btn btn-sm btn-outline-primary" @click="copyStreamUrl(channel.media_url, $event)">
                                                Stream <i class="bi bi-clipboard"></i>
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Pagination -->
                        <div class="pagination-container" v-if="channelsTotalPages > 1">
                            <nav aria-label="Channel list pagination">
                                <ul class="pagination">
                                    <li class="page-item" :class="{ disabled: channelsCurrentPage === 1 }">
                                        <a class="page-link" href="#" @click.prevent="loadChannelsPage(1)">First</a>
                                    </li>
                                    <li class="page-item" :class="{ disabled: channelsCurrentPage === 1 }">
                                        <a class="page-link" href="#" @click.prevent="loadChannelsPage(channelsCurrentPage - 1)">Previous</a>
                                    </li>

                                    <li v-for="page in paginationPages" :key="page" class="page-item" :class="{ active: channelsCurrentPage === page }">
                                        <a class="page-link" href="#" @click.prevent="loadChannelsPage(page)">[[ page ]]</a>
                                    </li>

                                    <li class="page-item" :class="{ disabled: channelsCurrentPage === channelsTotalPages }">
                                        <a class="page-link" href="#" @click.prevent="loadChannelsPage(channelsCurrentPage + 1)">Next</a>
                                    </li>
                                    <li class="page-item" :class="{ disabled: channelsCurrentPage === channelsTotalPages }">
                                        <a class="page-link" href="#" @click.prevent="loadChannelsPage(channelsTotalPages)">Last</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Job History Modal -->
    <div class="modal fade" id="jobHistoryModal" tabindex="-1" aria-labelledby="jobHistoryModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="jobHistoryModalLabel">Sync History for "[[ currentProvider.name ]]"</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div v-if="jobsLoading" class="text-center p-4">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Loading sync history...</p>
                    </div>

                    <div v-else-if="jobsError" class="alert alert-danger">
                        [[ jobsError ]]
                    </div>

                    <div v-else-if="jobs.length === 0 && activeJobsForCurrentProvider.length === 0" class="alert alert-info">
                        No sync jobs found for this provider.
                    </div>

                    <div v-else>
                        <!-- Active Jobs Section -->
                        <div v-if="activeJobsForCurrentProvider.length > 0" class="active-jobs-section">
                            <h5 class="mb-3">Active Jobs</h5>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>Status</th>
                                            <th>Description</th>
                                            <th>Attempts</th>
                                            <th>Last Attempt</th>
                                            <th>Updated</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr v-for="job in activeJobsForCurrentProvider" :key="job.id" :class="{'table-warning': job.state === 'InProgress', 'table-info': job.state === 'Queued'}">
                                            <td>
                                                <i class="bi" :class="{
                                                    'bi-hourglass-split': job.state === 'InProgress',
                                                    'bi-clock text-info': job.state === 'Queued'
                                                }"></i>
                                                <span class="job-state-badge" :class="{
                                                    'job-state-inprogress': job.state === 'InProgress',
                                                    'job-state-queued': job.state === 'Queued'
                                                }">[[ job.state ]]</span>
                                            </td>
                                            <td>[[ job.status_description || 'No description' ]]</td>
                                            <td>[[ job.attempt_count ]] / [[ job.max_attempts || '∞' ]]</td>
                                            <td>[[ job.last_attempt_started_at ? formatDate(job.last_attempt_started_at) : 'Not started' ]]</td>
                                            <td>[[ formatDate(job.updated_at) ]]</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- History Section -->
                        <div v-if="jobs.length > 0">
                            <h5 class="mb-3">History</h5>
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>Status</th>
                                            <th>Description</th>
                                            <th>Attempts</th>
                                            <th>Last Attempt</th>
                                            <th>Updated</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr v-for="job in jobs" :key="job.id" :class="{'table-success': job.state === 'Completed', 'table-danger': job.state === 'Failed'}">
                                            <td>
                                                <i class="bi" :class="{
                                                    'bi-check-circle-fill text-success': job.state === 'Completed',
                                                    'bi-x-circle-fill text-danger': job.state === 'Failed'
                                                }"></i>
                                                <span class="job-state-badge" :class="{
                                                    'job-state-completed': job.state === 'Completed',
                                                    'job-state-failed': job.state === 'Failed'
                                                }">[[ job.state ]]</span>
                                            </td>
                                            <td>[[ job.status_description || 'No description' ]]</td>
                                            <td>[[ job.attempt_count ]] / [[ job.max_attempts || '∞' ]]</td>
                                            <td>[[ job.last_attempt_started_at ? formatDate(job.last_attempt_started_at) : 'Not started' ]]</td>
                                            <td>[[ formatDate(job.updated_at) ]]</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>

                            <!-- Pagination -->
                            <div class="pagination-container" v-if="jobsTotalPages > 1">
                                <nav aria-label="Job history pagination">
                                    <ul class="pagination">
                                        <li class="page-item" :class="{ disabled: jobsCurrentPage === 1 }">
                                            <a class="page-link" href="#" @click.prevent="loadJobsPage(1)">First</a>
                                        </li>
                                        <li class="page-item" :class="{ disabled: jobsCurrentPage === 1 }">
                                            <a class="page-link" href="#" @click.prevent="loadJobsPage(jobsCurrentPage - 1)">Previous</a>
                                        </li>

                                        <li v-for="page in jobsPaginationPages" :key="page" class="page-item" :class="{ active: jobsCurrentPage === page }">
                                            <a class="page-link" href="#" @click.prevent="loadJobsPage(page)">[[ page ]]</a>
                                        </li>

                                        <li class="page-item" :class="{ disabled: jobsCurrentPage === jobsTotalPages }">
                                            <a class="page-link" href="#" @click.prevent="loadJobsPage(jobsCurrentPage + 1)">Next</a>
                                        </li>
                                        <li class="page-item" :class="{ disabled: jobsCurrentPage === jobsTotalPages }">
                                            <a class="page-link" href="#" @click.prevent="loadJobsPage(jobsTotalPages)">Last</a>
                                        </li>
                                    </ul>
                                </nav>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-success" @click="syncProviderFromHistory()" :disabled="currentProvider.active_job_id">
                        <i class="bi" :class="currentProvider.active_job_id ? 'bi-hourglass-split' : 'bi-arrow-repeat'"></i>
                        <span v-if="currentProvider.active_job_id">Syncing...</span>
                        <span v-else>Sync Now</span>
                    </button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Create Vue app
    const app = new Vue({
        el: '#app',
        delimiters: ['[[', ']]'],
        data: {
            providers: [],
            loading: true,
            error: null,
            currentProvider: {
                id: null,
                name: '',
                url: '',
                channel_count: 0,
                created_at: null,
                updated_at: null,
                last_sync_started_at: null
            },
            editMode: false,
            formError: null,
            formSubmitting: false,
            providerModal: null,
            deleteModal: null,
            channelsModal: null,
            jobHistoryModal: null,
            // Channels data
            channels: [],
            channelsLoading: false,
            channelsError: null,
            channelsCurrentPage: 1,
            channelsTotalPages: 1,
            channelsPageSize: 10,
            // Jobs data
            jobs: [],
            activeJobs: [],
            jobsLoading: false,
            jobsError: null,
            jobsCurrentPage: 1,
            jobsTotalPages: 1,
            jobsPageSize: 10,
            // WebSocket connections
            activeJobsSocket: null,
            jobDetailSockets: {},
            // Settings data
            settings: {
                sync_enabled: false,
                sync_schedules: [],
                allow_channel_auto_deletion: true,
                sync_job_max_attempts: 3
            },
            settingsStatus: 'idle', // idle, modified, saving, saved
            settingsError: null,
            settingsTimeout: null,
            daysOfWeek: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        },
        mounted() {
            this.fetchProviders();
            this.fetchSettings();
            this.providerModal = new bootstrap.Modal(document.getElementById('providerModal'));
            this.deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
            this.channelsModal = new bootstrap.Modal(document.getElementById('channelsModal'));
            this.jobHistoryModal = new bootstrap.Modal(document.getElementById('jobHistoryModal'));

            // Connect to active jobs WebSocket
            this.connectToActiveJobsWebSocket();
        },

        beforeDestroy() {
            // Disconnect all WebSockets when component is destroyed
            this.disconnectWebSockets();
        },
        computed: {
            paginationPages() {
                // Generate an array of page numbers to display in pagination
                // Show at most 5 pages, centered around the current page
                const totalPages = this.channelsTotalPages;
                const currentPage = this.channelsCurrentPage;

                if (totalPages <= 5) {
                    // If there are 5 or fewer pages, show all of them
                    return Array.from({ length: totalPages }, (_, i) => i + 1);
                } else {
                    // Otherwise, show 5 pages centered around the current page
                    let startPage = Math.max(currentPage - 2, 1);
                    let endPage = startPage + 4;

                    if (endPage > totalPages) {
                        endPage = totalPages;
                        startPage = Math.max(endPage - 4, 1);
                    }

                    return Array.from({ length: endPage - startPage + 1 }, (_, i) => startPage + i);
                }
            },
            jobsPaginationPages() {
                // Generate an array of page numbers to display in pagination
                // Show at most 5 pages, centered around the current page
                const totalPages = this.jobsTotalPages;
                const currentPage = this.jobsCurrentPage;

                if (totalPages <= 5) {
                    // If there are 5 or fewer pages, show all of them
                    return Array.from({ length: totalPages }, (_, i) => i + 1);
                } else {
                    // Otherwise, show 5 pages centered around the current page
                    let startPage = Math.max(currentPage - 2, 1);
                    let endPage = startPage + 4;

                    if (endPage > totalPages) {
                        endPage = totalPages;
                        startPage = Math.max(endPage - 4, 1);
                    }

                    return Array.from({ length: endPage - startPage + 1 }, (_, i) => startPage + i);
                }
            },
            activeJobsForCurrentProvider() {
                return this.activeJobs.filter(j => j.job_id === this.currentProvider.active_job_id);
            }
        },
        methods: {
            fetchProviders() {
                this.loading = true;
                this.error = null;

                axios.get('/api/providers/')
                    .then(response => {
                        this.providers = response.data;
                        this.loading = false;
                    })
                    .catch(error => {
                        console.error('Error fetching providers:', error);
                        this.error = 'Failed to load providers. Please try again later.';
                        this.loading = false;
                    });
            },
            fetchProvider(providerId) {
                axios.get(`/api/providers/${providerId}/`)
                    .then(response => {
                        const providerIndex = this.providers.findIndex(s => s.id === providerId);
                        if (providerIndex !== -1) {
                            this.providers[providerIndex] = response.data;
                        }
                    })
                    .catch(error => {
                        console.error(`Error fetching provider '${providerId}':`, error);
                        this.error = 'Failed to load provider. Please try again later.';
                    });
            },

            syncProvider(provider) {
                // Start sync
                axios.post(`/api/providers/${provider.id}/sync/`)
                    .then(response => {
                        console.log('Sync initiated:', response.data);

                        provider.active_job_id = response.data.job_id;
                    })
                    .catch(error => {
                        console.error('Error initiating sync:', error);

                        // Show error in an alert
                        alert('Failed to initiate sync: ' + (error.response?.data?.error || 'Please try again.'));
                    });
            },

            showAddModal() {
                this.editMode = false;
                this.currentProvider = {
                    id: null,
                    name: '',
                    url: ''
                };
                this.formError = null;
                this.providerModal.show();
            },
            showEditModal(provider) {
                this.editMode = true;
                this.currentProvider = {
                    id: provider.id,
                    name: provider.name,
                    url: provider.url
                };
                this.formError = null;
                this.providerModal.show();
            },
            saveProvider() {
                this.formSubmitting = true;
                this.formError = null;

                const payload = {
                    name: this.currentProvider.name,
                    url: this.currentProvider.url
                }

                const request = this.editMode
                    ? axios.patch(`/api/providers/${this.currentProvider.id}/`, payload)
                    : axios.post('/api/providers/', payload);

                request
                    .then(() => {
                        this.providerModal.hide();
                        this.fetchProviders();
                        this.formSubmitting = false;
                    })
                    .catch(error => {
                        console.error('Error saving service provider:', error);
                        this.formError = 'Failed to save service provider. Please check your input and try again.';
                        this.formSubmitting = false;
                    });
            },

            toggleProviderEnabled(provider) {
                axios.patch(`/api/providers/${provider.id}/`, {
                    is_enabled: provider.is_enabled
                })
                .then(() => {
                    console.log(`Service provider ${provider.id} ${provider.is_enabled ? 'enabled' : 'disabled'}`);
                    // Refresh the providers to update the "Updated" timestamp
                    this.fetchProviders();
                })
                .catch(error => {
                    console.error('Error toggling service provider enabled state:', error);
                    // Revert the toggle if there was an error
                    provider.is_enabled = !provider.is_enabled;
                    this.$forceUpdate();
                    alert('Failed to update service provider status. Please try again.');
                });
            },
            confirmDelete(provider) {
                this.currentProvider = {
                    id: provider.id,
                    name: provider.name,
                    url: provider.url
                };
                this.deleteModal.show();
            },
            deleteProvider() {
                this.formSubmitting = true;

                axios.delete(`/api/providers/${this.currentProvider.id}/`)
                    .then(() => {
                        this.deleteModal.hide();
                        this.fetchProviders();
                        this.formSubmitting = false;
                    })
                    .catch(error => {
                        console.error('Error deleting provider:', error);
                        this.formSubmitting = false;
                        // Show error in delete modal
                        document.querySelector('#deleteModal .modal-body').innerHTML += 
                            `<div class="alert alert-danger mt-3">Failed to delete provider. Please try again later.</div>`;
                    });
            },
            formatDate(dateString) {
                if (!dateString) return 'N/A';
                const date = new Date(dateString);
                return date.toLocaleString();
            },

            // Settings methods
            fetchSettings() {
                axios.get('/api/settings/')
                    .then(response => {
                        const settingsData = response.data;

                        // Ensure sync_schedules is an array
                        if (!settingsData.sync_schedules) {
                            settingsData.sync_schedules = [];
                        }

                        // Convert schedule times from UTC (as stored on the server) to local browser time zone
                        // This ensures that users see schedules in their own time zone
                        if (settingsData.sync_schedules && settingsData.sync_schedules.length > 0) {
                            settingsData.sync_schedules.forEach(schedule => {
                                // Ensure each schedule has a daysOfWeek array
                                if (!schedule.daysOfWeek) {
                                    schedule.daysOfWeek = [];
                                }

                                if (schedule.time) {
                                    // Parse the UTC time string (HH:MM:SS)
                                    const timeParts = schedule.time.split(':');
                                    const utcHours = parseInt(timeParts[0], 10);
                                    const utcMinutes = parseInt(timeParts[1], 10);
                                    const utcSeconds = timeParts.length > 2 ? parseInt(timeParts[2], 10) : 0;

                                    // Create a Date object with the UTC time
                                    const utcDate = new Date();
                                    utcDate.setUTCHours(utcHours, utcMinutes, utcSeconds, 0);

                                    // Get the local time components
                                    const localHours = utcDate.getHours();
                                    const localMinutes = utcDate.getMinutes();
                                    const localSeconds = utcDate.getSeconds();

                                    // Format as HH:MM:SS
                                    schedule.time = 
                                        String(localHours).padStart(2, '0') + ':' + 
                                        String(localMinutes).padStart(2, '0') + ':' + 
                                        String(localSeconds).padStart(2, '0');

                                    // If the day changed due to timezone conversion, adjust the days of week
                                    // For example, if Monday 5am UTC becomes Sunday 10pm PT, we need to shift the day from Monday to Sunday
                                    if (utcDate.getUTCDate() !== utcDate.getDate()) {
                                        // Determine if we crossed forward or backward
                                        const dayDiff = (utcDate.getDay() - utcDate.getUTCDay() + 7) % 7;

                                        // Shift the days of week accordingly
                                        const shiftedDays = [];
                                        for (const day of schedule.daysOfWeek) {
                                            const dayIndex = this.daysOfWeek.indexOf(day);
                                            if (dayIndex !== -1) {
                                                const newDayIndex = (dayIndex + dayDiff) % 7;
                                                shiftedDays.push(this.daysOfWeek[newDayIndex]);
                                            }
                                        }
                                        schedule.daysOfWeek = shiftedDays;
                                    }
                                }
                            });
                        }

                        this.settings = settingsData;
                        this.settingsError = null;
                    })
                    .catch(error => {
                        console.error('Error fetching settings:', error);
                        this.settingsError = 'Failed to load settings. Please refresh the page.';
                    });
            },

            saveSettings() {
                this.settingsStatus = 'saving';

                // Create a deep copy of the settings to avoid modifying the original
                const settingsToSave = JSON.parse(JSON.stringify(this.settings));

                // Convert schedule times from local browser time zone to UTC
                // This ensures that schedules are stored in a consistent time zone on the server
                if (settingsToSave.sync_schedules && settingsToSave.sync_schedules.length > 0) {
                    settingsToSave.sync_schedules.forEach(schedule => {
                        if (schedule.time) {
                            // Parse the time string (HH:MM or HH:MM:SS)
                            const timeParts = schedule.time.split(':');
                            const hours = parseInt(timeParts[0], 10);
                            const minutes = parseInt(timeParts[1], 10);
                            const seconds = timeParts.length > 2 ? parseInt(timeParts[2], 10) : 0;

                            // Create a Date object for today with the specified time
                            const localDate = new Date();
                            localDate.setHours(hours, minutes, seconds, 0);

                            // Convert to UTC time
                            const utcHours = localDate.getUTCHours();
                            const utcMinutes = localDate.getUTCMinutes();
                            const utcSeconds = localDate.getUTCSeconds();

                            // Format as HH:MM:SS
                            schedule.time = 
                                String(utcHours).padStart(2, '0') + ':' + 
                                String(utcMinutes).padStart(2, '0') + ':' + 
                                String(utcSeconds).padStart(2, '0');

                            // If the day changed due to timezone conversion, adjust the days of week
                            // For example, if Sunday 10pm PT becomes Monday 5am UTC, we need to shift the day from Sunday to Monday
                            if (localDate.getUTCDate() !== localDate.getDate()) {
                                // Determine if we crossed forward or backward
                                const dayDiff = (localDate.getUTCDay() - localDate.getDay() + 7) % 7;

                                // Shift the days of week accordingly
                                const shiftedDays = [];
                                for (const day of schedule.daysOfWeek) {
                                    const dayIndex = this.daysOfWeek.indexOf(day);
                                    if (dayIndex !== -1) {
                                        const newDayIndex = (dayIndex + dayDiff) % 7;
                                        shiftedDays.push(this.daysOfWeek[newDayIndex]);
                                    }
                                }
                                schedule.daysOfWeek = shiftedDays;
                            }
                        }
                    });
                }

                axios.put('/api/settings/', settingsToSave)
                    .then(response => {
                        // Get the response data
                        const responseData = response.data;

                        // Convert schedule times from UTC (as stored on the server) to local browser time zone
                        // This ensures that users see schedules in their own time zone after saving
                        if (responseData.sync_schedules && responseData.sync_schedules.length > 0) {
                            responseData.sync_schedules.forEach(schedule => {
                                if (schedule.time) {
                                    // Parse the UTC time string (HH:MM:SS)
                                    const timeParts = schedule.time.split(':');
                                    const utcHours = parseInt(timeParts[0], 10);
                                    const utcMinutes = parseInt(timeParts[1], 10);
                                    const utcSeconds = timeParts.length > 2 ? parseInt(timeParts[2], 10) : 0;

                                    // Create a Date object with the UTC time
                                    const utcDate = new Date();
                                    utcDate.setUTCHours(utcHours, utcMinutes, utcSeconds, 0);

                                    // Get the local time components
                                    const localHours = utcDate.getHours();
                                    const localMinutes = utcDate.getMinutes();
                                    const localSeconds = utcDate.getSeconds();

                                    // Format as HH:MM:SS
                                    schedule.time = 
                                        String(localHours).padStart(2, '0') + ':' + 
                                        String(localMinutes).padStart(2, '0') + ':' + 
                                        String(localSeconds).padStart(2, '0');

                                    // If the day changed due to timezone conversion, adjust the days of week
                                    if (utcDate.getUTCDate() !== utcDate.getDate()) {
                                        // Determine if we crossed forward or backward
                                        const dayDiff = (utcDate.getDay() - utcDate.getUTCDay() + 7) % 7;

                                        // Shift the days of week accordingly
                                        const shiftedDays = [];
                                        for (const day of schedule.daysOfWeek) {
                                            const dayIndex = this.daysOfWeek.indexOf(day);
                                            if (dayIndex !== -1) {
                                                const newDayIndex = (dayIndex + dayDiff) % 7;
                                                shiftedDays.push(this.daysOfWeek[newDayIndex]);
                                            }
                                        }
                                        schedule.daysOfWeek = shiftedDays;
                                    }
                                }
                            });
                        }

                        // Update the settings with the converted response data
                        this.settings = responseData;
                        this.settingsStatus = 'saved';
                        this.settingsError = null;

                        // Reset status after 3 seconds
                        setTimeout(() => {
                            if (this.settingsStatus === 'saved') {
                                this.settingsStatus = 'idle';
                            }
                        }, 3000);
                    })
                    .catch(error => {
                        console.error('Error saving settings:', error);
                        this.settingsError = 'Failed to save settings. Please try again.';
                        this.settingsStatus = 'idle';
                    });
            },

            onSettingsChange() {
                this.settingsStatus = 'modified';

                // Clear existing timeout
                if (this.settingsTimeout) {
                    clearTimeout(this.settingsTimeout);
                }

                // Set new timeout to save after 3 seconds of inactivity
                this.settingsTimeout = setTimeout(() => {
                    this.saveSettings();
                }, 3000);
            },

            addNewSchedule() {
                // Add a new empty schedule with default time and no days selected
                this.settings.sync_schedules.push({
                    daysOfWeek: [],
                    time: '12:00'
                });
                this.onSettingsChange();
            },

            removeSchedule(index) {
                // Remove a schedule at the specified index
                this.settings.sync_schedules.splice(index, 1);
                this.onSettingsChange();
            },

            applyQuickSchedule(scheduleIndex, type) {
                // Get the schedule at the specified index
                const schedule = this.settings.sync_schedules[scheduleIndex];

                // Set days based on selection type
                if (type === 'all') {
                    schedule.daysOfWeek = [...this.daysOfWeek]; // All days
                } else if (type === 'weekdays') {
                    schedule.daysOfWeek = this.daysOfWeek.slice(0, 5); // Monday to Friday
                } else if (type === 'weekend') {
                    schedule.daysOfWeek = this.daysOfWeek.slice(5, 7); // Saturday and Sunday
                }

                this.onSettingsChange();
            },

            // Channel list methods
            showChannelsModal(provider) {
                // Set current provider
                this.currentProvider = {
                    id: provider.id,
                    name: provider.name,
                    url: provider.url
                };

                // Reset channels data
                this.channels = [];
                this.channelsCurrentPage = 1;
                this.channelsTotalPages = 1;
                this.channelsError = null;

                // Show modal
                this.channelsModal.show();

                // Load first page of channels
                this.loadChannelsPage(1);
            },

            loadChannelsPage(page) {
                this.channelsLoading = true;
                this.channelsError = null;

                // Fetch channels for the specified page
                axios.get(`/api/providers/${this.currentProvider.id}/channels/`, {
                    params: {
                        page: page,
                        size: this.channelsPageSize
                    }
                })
                .then(response => {
                    // Update channels data
                    this.channels = response.data.items;
                    this.channelsCurrentPage = response.data.page;
                    this.channelsTotalPages = Math.ceil(response.data.total / this.channelsPageSize);
                    this.channelsLoading = false;
                })
                .catch(error => {
                    console.error('Error fetching channels:', error);
                    this.channelsError = 'Failed to load channels. Please try again.';
                    this.channelsLoading = false;
                });
            },

            handleLogoError(event) {
                // Replace broken image with a placeholder or hide it
                event.target.style.display = 'none';
            },

            copyStreamUrl(url, event) {
                // Copy the stream URL to clipboard
                navigator.clipboard.writeText(url)
                    .then(() => {
                        // Show a temporary success message
                        const button = event.target.closest('button');
                        const originalText = button.innerHTML;

                        button.innerHTML = '<i class="bi bi-check"></i> Copied!';
                        button.classList.remove('btn-outline-primary');
                        button.classList.add('btn-success');

                        // Reset button after 2 seconds
                        setTimeout(() => {
                            button.innerHTML = originalText;
                            button.classList.remove('btn-success');
                            button.classList.add('btn-outline-primary');
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy URL:', err);
                        alert('Failed to copy URL. Please try again.');
                    });
            },

            // Job History Methods
            showJobHistoryModal(provider) {
                // Set current provider
                this.currentProvider = provider;

                // Reset jobs data
                this.jobs = [];
                this.jobsCurrentPage = 1;
                this.jobsTotalPages = 1;
                this.jobsError = null;

                // Show modal
                this.jobHistoryModal.show();

                // Load first page of jobs
                this.loadJobsPage(1);
            },

            loadJobsPage(page) {
                if (!this.jobHistoryModal._isShown) return;

                this.jobsLoading = true;
                this.jobsError = null;

                // Fetch jobs for the specified page
                axios.get(`/api/providers/${this.currentProvider.id}/jobs/`, {
                    params: {
                        page: page,
                        size: this.jobsPageSize
                    }
                })
                .then(response => {
                    // Update jobs data
                    this.jobs = response.data.items;
                    this.jobsCurrentPage = response.data.page;
                    this.jobsTotalPages = Math.ceil(response.data.total / this.jobsPageSize);
                    this.jobsLoading = false;
                })
                .catch(error => {
                    console.error('Error fetching jobs:', error);
                    this.jobsError = 'Failed to load sync history. Please try again.';
                    this.jobsLoading = false;
                });
            },

            syncProviderFromHistory() {
                // Start sync
                axios.post(`/api/providers/${this.currentProvider.id}/sync/`)
                    .then(response => {
                        console.log('Sync initiated from history modal:', response.data);

                        this.currentProvider.active_job_id = response.data.job_id;
                    })
                    .catch(error => {
                        console.error('Error initiating sync from history modal:', error);

                        this.jobsError = error.response?.data?.error || 'Failed to initiate sync. Please try again.';
                    });
            },

            // WebSocket methods
            connectToActiveJobsWebSocket() {
                // Close existing connection if any
                if (this.activeJobsSocket) {
                    this.activeJobsSocket.close();
                }

                // Create a new WebSocket connection
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/active-jobs/`;

                this.activeJobsSocket = new WebSocket(wsUrl);

                // Set up event handlers
                this.activeJobsSocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'active_jobs_update') {
                        // Update providers with active job information
                        this.updateProvidersWithActiveJobs(data.active_jobs);
                    }
                };

                this.activeJobsSocket.onclose = () => {
                    console.log('Active jobs WebSocket connection closed');
                    // Try to reconnect after a delay
                    setTimeout(() => this.connectToActiveJobsWebSocket(), 5000);
                };

                this.activeJobsSocket.onerror = (error) => {
                    console.error('Active jobs WebSocket error:', error);
                };
            },

            disconnectWebSockets() {
                // Close active jobs WebSocket
                if (this.activeJobsSocket) {
                    this.activeJobsSocket.close();
                    this.activeJobsSocket = null;
                }
            },

            updateProvidersWithActiveJobs(activeJobs) {
                // Create a map of provider IDs to active job IDs
                const providerActiveJobs = {};
                activeJobs.forEach(activeJob => {
                    providerActiveJobs[activeJob.provider_id] = activeJob.job;
                });

                // Update each provider
                let updateHistoryModal = false;
                this.providers.forEach(provider => {
                    const currentActiveJob = providerActiveJobs[provider.id];
                    const previousActiveJob = this.activeJobs.find(j => j.job_id === provider.active_job_id);

                    // If the provider has an active job
                    if (currentActiveJob) {
                        provider.active_job_id = currentActiveJob.job_id;

                        if (currentActiveJob.job_id !== previousActiveJob?.job_id) updateHistoryModal = true;
                    } else {
                        provider.active_job_id = null;

                        if (previousActiveJob) {
                            updateHistoryModal = true;

                            this.fetchProvider(provider.id);
                        }
                    }
                });

                // Set active jobs
                this.activeJobs = Object.values(providerActiveJobs);

                if(updateHistoryModal) {
                    // Refresh the history section
                    this.loadJobsPage(this.jobsCurrentPage);
                }

                // Force Vue to update the UI
                this.$forceUpdate();
            },
        }
    });
</script>
{% endblock %}
